<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Terraform Module Brainrot | gustavderdrache</title>
  <link rel="stylesheet" href="/style.css" integrity="sha384-8K6EgpVB4POw0RmbdSDJk4i10ulnclu+0Av0DLZnVx2l1sfJsoZRVQXeZ3Vzln9c"/>
</head>
<body>
  <header>
    <h1>Terraform Module Brainrot</h1>
    <p>513 word(s) | 3 min reading time</p>
  </header>

  <main>
    <p>When your code structure starts with making modules first, it leads you to extremely silly places. Take this <a href="https://github.com/terraform-aws-modules/terraform-aws-cloudwatch/tree/master/modules/log-group">CloudWatch log group module</a>, which I have reproduced in its entirety below:</p>
<pre data-lang="hcl" style="background-color:#2b303b;color:#c0c5ce;" class="language-hcl "><code class="language-hcl" data-lang="hcl"><span>resource &quot;aws_cloudwatch_log_group&quot; &quot;this&quot; {
</span><span>  count = var.create ? 1 : 0
</span><span>
</span><span>  name              = var.name
</span><span>  name_prefix       = var.name_prefix
</span><span>  retention_in_days = var.retention_in_days
</span><span>  kms_key_id        = var.kms_key_id
</span><span>  log_group_class   = var.log_group_class
</span><span>  skip_destroy      = var.skip_destroy
</span><span>
</span><span>  tags = var.tags
</span><span>}
</span></code></pre>
<p>What is this? Why is it here? What possible purpose could making this a module serve? Why not just… create a log group?</p>
<p>If you think you have an answer… think carefully. In my experience, Terraform seems to treat modules slightly differently with respect to meta-arguments, so mixing things like <code>count</code> and <code>depends_on</code> can cause issues. Module handling lags behind (sometimes far behind) resource handling. This means that by reaching for modules first for everything, you've given up Terraform's resource handling for more limited functionality. Why? Why do this?</p>
<p>What's worse about this is that the module interface can sometimes create or hide really awkward behavior. For example, take <a href="https://github.com/terraform-aws-modules/terraform-aws-dynamodb-table/tree/master">the DynamoDB module</a>. This module has some quirks: because it's behind a module, you can't add extra ignores, so the module forces you to migrate between no less than three different resources in various scenarios. For example, if you change autoscaling, then you have to heed this warning:</p>
<blockquote>
<p>There are two separate Terraform resources used for the DynamoDB table: one is for when any autoscaling is enabled the other when disabled. If your table is already created and then you change the variable autoscaling_enabled then your table will be recreated by Terraform. In this case you will need to move the old <code>aws_dynamodb_table</code> resource that is being <code>destroyed</code> to the new resource that is being <code>created</code>.</p>
</blockquote>
<p>What's so different about an autoscaled DynamoDB table? As of the time of writing (<a href="https://github.com/terraform-aws-modules/terraform-aws-dynamodb-table/tree/e47cf5f0d2636bd5018b4a65e988295d5360cbb6">commit <code>e47cf5f0d2636bd5018b4a65e988295d5360cbb6</code></a>), the full difference between the two tables is below:</p>
<pre data-lang="diff" style="background-color:#2b303b;color:#c0c5ce;" class="language-diff "><code class="language-diff" data-lang="diff"><span>@@ -1,5 +1,5 @@
</span><span style="color:#bf616a;">-resource &quot;aws_dynamodb_table&quot; &quot;this&quot; {
</span><span style="color:#bf616a;">-  count = var.create_table &amp;&amp; !var.autoscaling_enabled ? 1 : 0
</span><span style="color:#a3be8c;">+resource &quot;aws_dynamodb_table&quot; &quot;autoscaled&quot; {
</span><span style="color:#a3be8c;">+  count = var.create_table &amp;&amp; var.autoscaling_enabled &amp;&amp; !var.ignore_changes_global_secondary_index ? 1 : 0
</span><span>
</span><span>   name                        = var.name
</span><span>   billing_mode                = var.billing_mode
</span><span>@@ -136,4 +136,8 @@
</span><span>     delete = lookup(var.timeouts, &quot;delete&quot;, null)
</span><span>     update = lookup(var.timeouts, &quot;update&quot;, null)
</span><span>   }
</span><span style="color:#a3be8c;">+
</span><span style="color:#a3be8c;">+  lifecycle {
</span><span style="color:#a3be8c;">+    ignore_changes = [read_capacity, write_capacity]
</span><span style="color:#a3be8c;">+  }
</span><span> }
</span></code></pre>
<p>The difference is… nothing. It's kind of worse than nothing, actually. The presence of the autoscaling variable is strictly to ignore the capacity changes, and since this can't be dynamic, the fact that this one table is wrapped in a module forces you to do <em>more</em> work than if you simply had direct access to the resource definition—you have to perform <code>terraform state mv</code> commands to switch, instead of just updating a few lines of source code! Again, in a case like this, why reach for a module at all? What is being gained here that couldn't be better served by just writing the resource out, especially if the module functionality actually impedes development?</p>
<p>These aren't isolated incidents, either. You can find this kind of nonsense everywhere, riddled with the same flaws—<a href="https://github.com/terraform-aws-modules/terraform-aws-ssm-parameter">SSM parameters</a>, <a href="https://github.com/terraform-aws-modules/terraform-aws-key-pair">EC2 key pairs</a>, and so on. Is the overhead worth it? Why?</p>
<p>What are these modules meant to <em>do</em>, other than add overhead for the sake of being able to say "Yes, we're using modules!" What value does that bring?</p>

  </main>
</body>
</html>
